<!DOCTYPE html>
<html>
	<head>
		<title>GLFX</title>

		<link rel="stylesheet" type="text/css" href="../../semantic/semantic.min.css">
		<link rel="stylesheet" type="text/css" href="https://tyleryasaka.github.io/semantic-ui-range/range.css">
		
	</head>
	<body>
		<style type="text/css">
		* { margin: 0; padding: 0; }
		body, html {
			width: 100%;
			height: 100%;
		}
		.glfx {
			position: absolute;
			width: 100%;
			height: 100%;
		}
		.floating {
			position: absolute;
			width: 280px;
			z-index: 10;
			left: 10px;
			top: 10px;
			background: #fff;
			padding: 12px;
			box-sizing: border-box;
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
		}
		</style>
		<script id="terrainV" type="x-shader/x-vertex">
			precision highp float;
			attribute vec3 vPosition;
			attribute vec3 vNormal;
			attribute vec2 vUV;
			attribute vec4 vColor;

			uniform mat4 mProjection;
			uniform mat4 mView;
			uniform mat4 mModel;

			varying vec4 oPosition;
			varying vec3 oNormal;
			varying vec2 oUV;
			varying vec4 oColor;

			void main() {
				mat4 mViewModel = mView * mModel;
				vec4 pos = mViewModel * vec4(vPosition, 1.0);
				gl_Position = mProjection * pos;
				oNormal = normalize(mModel * vec4(vNormal, 0.0)).xyz;
				oUV = vUV;
				oColor = vColor;
				oPosition = pos;
			}
		</script>
		<script id="terrainF" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 oPosition;
			varying vec3 oNormal;
			varying vec2 oUV;
			varying vec4 oColor;

			uniform sampler2D tGrass;
			uniform sampler2D tRock;
			uniform sampler2D tSnow;

			uniform vec3 uLightDir;

			vec3 color_from_height(float height, float uvscale) {
				vec3 terrain_colours[3];
				terrain_colours[0] = texture2D(tGrass, oUV * uvscale).rgb;
				terrain_colours[1] = texture2D(tRock, oUV * uvscale).rgb;
				terrain_colours[2] = texture2D(tSnow, oUV * uvscale).rgb;

				float hscaled = height * 2.0 - 1e-05;
				int hi = int(hscaled);
				float hfrac = (hscaled - float(hi));
				if (hi == 0)
					return mix(terrain_colours[0], terrain_colours[1], hfrac);
				else
					return mix(terrain_colours[1], terrain_colours[2], hfrac);
				return vec3(0.0, 0.0, 0.0);
			}

			void main() {
				float height = (oColor.r + oColor.g + oColor.b) / 3.0;
				vec3 V = normalize(-oPosition.xyz);
				vec3 N = normalize(oNormal);
				vec3 L = uLightDir;

				float nl = clamp(dot(N, L) * 3.0, 0.0, 1.0) * 0.5 + 0.5;
				vec3 lighting = nl * vec3(0.66, 0.75, 0.84);

				float rim = 1.0 - clamp(dot(V, N), 0.0, 1.0);

				vec3 col = color_from_height(height, 16.0);
				
				vec3 rimColor = vec3(0.44, 0.25, 0.16);
				vec3 rimL = rimColor * pow(rim, 1.6);
				
				vec3 finalColor = col * (lighting + rimL);
				
				gl_FragColor = vec4(finalColor, 1.0);
			}
		</script>

		<script
			src="https://code.jquery.com/jquery-3.1.1.min.js"
			integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
			crossorigin="anonymous"></script>
		<script src="../../semantic/components/accordion.min.js"></script>
		<script src="https://tyleryasaka.github.io/semantic-ui-range/range.js"></script>
		<script src="../../semantic/semantic.min.js"></script>
		<script language='javascript'>
			$(document).ready(function(){
				$('.ui.accordion').accordion();
			});
		</script>

		<script type="text/javascript" src="./src/glfx.js"></script>
		<canvas class="glfx" id="glfx" width="640" height="480">
			ERROR
		</canvas>

		<!-- UI -->
		<div class="ui form floating">
			<div class="ui medium header">Terrain Generator</div>
			<div class="ui">
				<div>
					<label for="file" class="ui icon button fluid">
						<i class="file icon"></i>
						Select File
					</label>
					<input type="file" id="file" style="display:none">
				</div>
				<br>
				<p>Light Direction</p>
				<div class="ui segment">
					<div class="ui range red" id="lx"></div>
					<div class="ui range green" id="ly"></div>
					<div class="ui range blue" id="lz"></div>
				</div>
				<p>Scale</p>
				<div class="ui input">
					<input type="number" min="0.1" max="1.0" value="0.2" step="0.01" id="scale" />
				</div>
				<p>Height</p>
				<div class="ui input">
					<input type="number" min="1.0" max="255.0" value="2.5" step="0.1" id="hscale" />
				</div>
				<div class="ui small header">Preview</div>
				<img id="out_preview" class="ui small bordered image rounded fluid" src="../../img/image.png">
			</div>
			<br>
			<button id="btn_gen" class="ui positive fluid button">
				<i class="cog icon"></i>
				Generate
			</button>
			<div id="gen_loader" class="ui dimmer">
				<div class="ui loader"></div>
			</div>
		</div>
		<!-- UI -->

		<script type="text/javascript">
			var _ = GLFX;
			_.createContext("glfx");
			var canvas = _.Canvas;
			var gl = _.GL;

			var FOV = 50;

			gl.enable(gl.DEPTH_TEST);
			gl.enable(gl.CULL_FACE);

			var proj = _.Mat4.perspective(Math.radians(FOV), canvas.width / canvas.height, 0.01, 1000.0);;
			var view = _.Mat4.ident();
			var model = _.Mat4.ident();

			var pivot = _.Mat4.rotationX(Math.radians(-45));
			var cameraT = _.Mat4.translation(0, 0, -10);

			var shader = _.Shader.fromHTMLElement("terrainV", "terrainF");
			
			var grass = new _.Texture2D("./grass.png");
			var rock = new _.Texture2D("./rock.png");
			var snow = new _.Texture2D("./snow.png");

			var terrain = null;
			var image = null;
			var imageValid = false;

			var lightDir = new _.Vec3(1.0, 1.0, 1.0);

			class Vert {
				constructor(position, uv, normal, color) {
					this.position = position;
					this.uv = uv;
					this.normal = normal;
					this.color = color;
				}
				getFormat() {
					let fmt = new _.VertexFormat();
					fmt.add("vPosition", 3, false);
					fmt.add("vNormal", 3, false);
					fmt.add("vUV", 2, false);
					fmt.add("vColor", 4, true);
					return fmt;
				}
				toArray() {
					return [
						this.position.x, this.position.y, this.position.z,
						this.normal.x, this.normal.y, this.normal.z,
						this.uv.x, this.uv.y,
						this.color.x, this.color.y, this.color.z, this.color.w
					];
				}
				getPosition() {
					return this.position;
				}
				getNormal() {
					return this.normal;
				}
				setNormal(n) {
					this.normal = n;
				}
			}

			function asyncRun(func) {
				setTimeout(func, 10);
			}

			let MAX_SIZE = 256;
			function loadHeightMap() {
				$("#gen_loader").addClass("active");
				function load(img, ondone) {
					var cv = document.createElement('canvas');
					var ctx = cv.getContext('2d');
					cv.width = img.width;
					cv.height = img.height;
					ctx.drawImage(img, 0, 0);

					var STEP = 4;
					var SCALE = document.getElementById("scale").value;
					var HEIGHT_SCALE = document.getElementById("hscale").value;
					if (!imageValid) {
						SCALE = 0.25;
						HEIGHT_SCALE = 7.0;
					} else {
						STEP = ~~(img.width / MAX_SIZE);
					}

					let TSIZE = ~~(img.width / STEP);

					if (terrain !== null) {
						terrain.destroy();
					}
					terrain = new _.Mesh(true, true);
					for (let y = 0; y < TSIZE; y++) {
						for (let x = 0; x < TSIZE; x++) {
							let color = ctx.getImageData(x * STEP, y * STEP, 1, 1).data;
							let rh = (color[0] / 255.0);
							let gh = (color[1] / 255.0);
							let bh = (color[2] / 255.0);
							let avgh = (rh + gh + bh) / 3.0;
							let height = (avgh * HEIGHT_SCALE);
							let u = x / TSIZE;
							let v = y / TSIZE;
							terrain.addVertex(
								new Vert(
									new _.Vec3(
										(x - TSIZE / 2) * SCALE,
										height,
										(y - TSIZE / 2) * SCALE,
									),
									new _.Vec2(u, v),
									new _.Vec3(),
									new _.Vec4(rh, gh, bh, 1.0)
								)
							);
						}
					}
					for (let y = 0; y < TSIZE-1; y++) {
						for (let x = 0; x < TSIZE; x++) {
							let i = x + y * TSIZE;
							let ni = x + (y + 1) * TSIZE;
							terrain.addIndex(i);
							terrain.addIndex(ni);
						}
						terrain.addIndex((y + 2) * TSIZE - 1);
						terrain.addIndex((y + 1) * TSIZE );
					}
					
					terrain.process(new _.NormalCalculator(gl.TRIANGLE_STRIP));
					terrain.flush();

					if (ondone) ondone();
				}

				if (!imageValid) {
					image = new Image();
					image.onload = async function() {
						asyncRun(function() {
							load(image, function() { $("#gen_loader").removeClass("active"); });
						});
						imageValid = true;
					};
					image.src = "./terrain3.png";
				} else {
					asyncRun(function() {
						load(image, function() { $("#gen_loader").removeClass("active"); });
					});
				}
			}
			loadHeightMap();
			
			$('#lx').range({
				min: 0,
				max: 100,
				start: 100,
				onChange: function(value) {
					lightDir.x = ((value / 100.0) * 2.0 - 1.0) * Math.PI;
				}
			});
			
			$('#ly').range({
				min: 0,
				max: 100,
				start: 100,
				onChange: function(value) {
					lightDir.y = ((value / 100.0) * 2.0 - 1.0) * Math.PI;
				}
			});
			
			$('#lz').range({
				min: 0,
				max: 100,
				start: 100,
				onChange: function(value) {
					lightDir.z = ((value / 100.0) * 2.0 - 1.0) * Math.PI;
				}
			});

			$("#btn_gen").click(function() {
				loadHeightMap();
			});

			$("#file").change(function() {
				imageValid = false;
				if (this.files && this.files[0]) {
					var reader = new FileReader();
					reader.onload = function(e) {
						image = new Image();
						image.onload = function() {
							imageValid = true;
						};
						image.src = e.target.result;
						$("#out_preview").attr("src", e.target.result);
					};
					reader.readAsDataURL(this.files[0]);
				}
			});

			let rot = 0;
			window.onresize = function(e) {
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
				proj = _.Mat4.perspective(Math.radians(FOV), canvas.width / canvas.height, 0.01, 1000.0);
				gl.viewport(0, 0, canvas.width, canvas.height);
			};
			window.onresize(null);

			var mx, my, mpx, mpy, mdx, mdy;
			var manip = false, move = false;
			var d = new _.Vec3();
			window.onkeydown = function(e) {
				switch (e.keyCode) {
					case 87: d.set(0, 0, 0.1); move = true; break;
					case 83: d.set(0, 0, -0.1); move = true; break;
					case 68: d.set(-0.1, 0, 0); move = true; break;
					case 65: d.set(0.1, 0, 0); move = true; break;
					// case 87: pivot = _.Mat4.translation(0, 0, 0.1).mul(pivot); break;
					// case 83: pivot = _.Mat4.translation(0, 0, -0.1).mul(pivot); break;
					// case 68: pivot = _.Mat4.translation(-0.1, 0, 0).mul(pivot); break;
					// case 65: pivot = _.Mat4.translation(0.1, 0, 0).mul(pivot); break;
				}
			};

			window.onkeyup = function(e) {
				move = false;
			};

			canvas.onmousedown = function(evt) {
				var rect = canvas.getBoundingClientRect();
				mx = evt.clientX - rect.left;
				my = evt.clientY - rect.top;
				mpx = mx;
				mpy = my;
				manip = true;
			};

			canvas.onmousemove = function(evt) {
				if (manip) {
					var rect = canvas.getBoundingClientRect();
					mx = evt.clientX - rect.left;
					my = evt.clientY - rect.top;
					mdx = mx - mpx;
					mdy = my - mpy;
					mpx = mx;
					mpy = my;

					//pivot = pivot.mul(_.Mat4.rotationX(-mdy * 0.005));
					pivot = _.Mat4.rotationY(mdx * 0.005).mul(pivot);
				}
			};

			canvas.onmouseup = function(evt) {
				manip = false;
			};

			canvas.onmousewheel = function(e) {
				var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
				cameraT = cameraT.mul(_.Mat4.translation(0, 0, delta * 0.3));
			};

			function mainLoop() {
				var M = _.Mat4.rotationZ(lightDir.z)
						.mul(_.Mat4.rotationY(lightDir.y))
						.mul(_.Mat4.rotationX(lightDir.x));
				var L = M.mul(new _.Vec4(0, 1, 0, 0));

				view = pivot.mul(cameraT);

				gl.clearColor(0, 0, 0, 1.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				if (terrain !== null) {
					grass.bind(0);
					rock.bind(1);
					snow.bind(2);

					shader.bind();
					shader.getUniform("mProjection").setMat4(proj);
					shader.getUniform("mView").setMat4(view);
					shader.getUniform("mModel").setMat4(model);
					shader.getUniform("tGrass").setInt(0);
					shader.getUniform("tRock").setInt(1);
					shader.getUniform("tSnow").setInt(2);
					shader.getUniform("uLightDir").setVec3(L);
					terrain.bind(shader);
					terrain.render(gl.TRIANGLE_STRIP);
					terrain.unbind();
				}

				_.nextFrame(mainLoop);
			}

			mainLoop();
		</script>
	</body>
</html>